//Bruteforce/Intuitive Approach (The sign bit/leftMost bit is 1 in negative numbers, and 0 in positive numbers)

class Solution {
    public static String areSame(int num1, int num2) {
        int mask = 1 << 31;
        int signNum1 = 0;// intially assume Num1 is +ve
        int signNum2 = 0;// intially assume Num2 is +ve

        if ((num1 & mask) != 0) {// if num1 is -ve
            signNum1 = 1;
        }
        if ((num2 & mask) != 0) {// if num2 is -ve
            signNum2 = 1;
        }

        if ((signNum1 == 0 && signNum2 == 1) || (signNum1 == 1 && signNum2 == 0)) {
            return "opposite Signs";
        }

        return "Same Sign";
    }
}

// Method 2
/*
 * Let the given integers be x and y. The sign bit is 1 in negative numbers, and 0 in positive numbers.
 * The XOR of x and y will have the sign bit as 1 iff they have opposite sign.
 */

class Solution {
    public static String areSame(int num1, int num2) {
        int xor = num1 ^ num2;
        int mask = 1 << 31;

        return (xor & mask) != 0 ? "opposite Signs" : "Same Sign";
    }
}

// Method 3
/*
 * Let the given integers be x and y. The sign bit is 1 in negative numbers, and 0 in positive numbers.
 * The XOR of x and y will have the sign bit as 1 iff they have opposite sign.
 * In other words, XOR of x and y will be negative number number iff x and y have opposite signs.
 */

class Solution {
    public static String areSame(int num1, int num2) {
        int xor = num1 ^ num2;
        return xor < 0 ? "opposite Signs" : "Same Sign";
    }
}
